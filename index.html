<!DOCTYPE html>
<html lang="pt">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<style>
  .axis path, .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
      //shape-rendering: geometricPrecision;
  }   
  .axis .grid-line{
      stroke: black;
      stroke-opacity: .2;
      shape-rendering: crispEdges;
  }
  #fittedLineSalBudget {
      shape-rendering: geometricPrecision;
      stroke: cadetblue;
      stroke-width: 6px;
      fill: none;
      opacity: 0.8;
      stroke-linecap: round;
  }
  .muniBubble {
      stroke: gold;
      stroke-width: 1px;
      stroke-opacity: 0.8;
      fill-opacity: 0.8;
  }
  circle.RM_Baixada_Santista {
      stroke: gold;
  }
  div#tooltip {
      position: absolute;
      text-align: center;
      background: cyan;
      color: olivedrab;
      border: 2px solid;
	    border-radius: 5px;
  }
</style>
<body>

<!--Language Selection-->
<select id="langSelect" onchange="changeLanguage()">
  <option value="EN">English
  <option value="PT">Portugues
</select>
<!--MicroRegion Selection-->
<select id="microSelect" onchange="selectMicroRegion()">
  <option value="muniBubble">MicroRegions
  <option value="Franco_da_Rocha">Franco da Rocha
  <option value="Guarulhos">Guarulhos
  <option value="Itapecerica_da_Serra">Itapecerica da Serra
  <option value="Mogi_das_Cruzes">Mogi das Cruzes
  <option value="Osasco">Osasco
  <option value="Santos">Santos
  <option value="Sao_Paulo">Sao Paulo
</select>


<p></p>
</body>
<script src="lib/d3.js"></script>
<script>
//Select the language
var lang = "EN"; //default
//var lang = "PT";

//First establish and render a viewing area
var width = 960;
var height = 600;

//color scale for styling (NOT USED)
var colorScale = d3.scale.linear()
    .domain([0, 30000, 122000])
    .range(["blue", "steelblue", "red"]);

//bubble coloring scheme
var bubbleColors = {main: "olivedrab", flash: "cyan", highlight: "yellow", background: "lightgray"};
var bubbleStrokeColor = {main: "gold", highlight: "olivedrab"};
var hatPathColor = {main: "cadetblue", background: "lightgray"};

//initialize chart object
//range stays at 0 to 30. Can zoom in or out on x. Good values are 180, 270, and 3300
var chart = chartObj()
        .y(d3.scale.linear().domain([0, 30]))
        .x(d3.scale.linear().domain([0, 270]));

//Load Data and Execute Script
d3.tsv("data/salaryData.txt")
  .row(function(d) {
  return {
    muniId: d.muniId, 
    muniName: d.muniName, 
    metroRegion: d.metroRegion, 
    microName: d.microName, 
    partyOfMayor2012: d.partyOfMayor2012, 
    pop1k2012: +d.pop1k2012,    //convert all vars below to number
    budget1M2012: +d.budget1M2012, 
    salaryMayor1k2014: +d.salaryMayor1k2014, 
    fitBudgetPop: +d.fitBudgetPop, 
    gapBudgetPop: +d.gapBudgetPop, 
    fitSalaryPop: +d.fitSalaryPop, 
    gapSalaryPop: +d.gapSalaryPop, 
    fitSalaryBudget: +d.fitSalaryBudget, 
    gapSalaryBudget: +d.gapSalaryBudget, 
    flagSalaryMissing: +d.flagSalaryMissing, 
    flagBudgetMissing: +d.flagBudgetMissing
  }; 
})
.get(function(error, data) {  
  //we now have access to an array of objects using the variable: "data"
  //load variable names
  d3.tsv("data/varLabels.txt", function(error, varInfo) {
    console.log(varInfo);
    //project code here. Use "data" as dataset variable and "varInfo" for variable labels.

        //load data
        chart.observations(data)
             .variableInfo(varInfo);

        //render the chart
        chart.render();

  });

//see first row of dataset and test for unicode characters
console.log(data[0]);
//d3.select("p").text(data[0].muniName);
});

//reset the language
function changeLanguage(){
  lang = document.getElementById("langSelect").value;
  //d3.selectAll(".text").remove();
  //console.log(chart);
  chart.render();
}

var microRegion = "";  //initialize as global var
function selectMicroRegion(){
  microRegion = document.getElementById("microSelect").value;
  if(microRegion == "muniBubble"){
    //default settings
    d3.selectAll("." + microRegion)
      .style("fill", bubbleColors.main)
      .style("stroke-width", "1px")
      .style("fill-opacity", "0.8");
    d3.selectAll(".dataMissing")
      .style("fill", bubbleColors.background);
    d3.select("#fittedLineSalBudget")
      .style("opacity", "0.8")
      .style("stroke", hatPathColor.main);
  } else {
    //customized highligting
    d3.selectAll(".muniBubble")
      .style("fill", bubbleColors.background)
      .style("stroke-width", "0px")
      .style("fill-opacity", "0.3");
    d3.selectAll("." + microRegion)
      .style("fill", bubbleColors.highlight)
      .style("fill-opacity", "0.9")
      .style("stroke-width", "1px");
    d3.select("#fittedLineSalBudget")
      .style("opacity", "0.5")
      .style("stroke", hatPathColor.background);
  }
}

//chart object-function
function chartObj(observations){
  /*Chart object adapted from Data Visualization with D3.js Cookbook, Nick Qi Zhu*/
  //observations are the dataset. used below.
  var _observations = {}
  var _variableInfo = {}
  var _chart = {}  //container for the scatterplot and line chart

  var _width = 880, _height = 550 ;
  var _margins = {top: 60, left:60, right: 60, bottom: 60} ;
  var _x, _y, _svg, _bodyG, _axesG, _textG, _line, _fittedPath;
  var  _data = []; 
  //_colors = d3.scale.category10() ;
  
  //headline render function
  _chart.render = function() {
    //append chart svg element if not already present
    if(!_svg) {
      _svg = d3.select("body").append("svg")
          .attr("height", _height)
          .attr("width", _width);
    }
    //render axes (hack to avoid redrawing axes)
    if(!_axesG){ renderAxes(_svg);};
    //chart body and data
    renderBody(_svg);
    //axes labels, units, and title
    renderText(_svg);
    
    //tooltip div
    renderToolTip();
  }
  //render axes
  function renderAxes(svg){
    if(!_axesG){
      _axesG = svg.append("g")
              .attr("class", "axes");
    }
    
    renderXAxis();
    renderYAxis();
  }
  function renderXAxis(){
    var xAxis = d3.svg.axis()
          .scale(_x.range([0, quadrantWidth()]))
          .orient("bottom");

    _axesG.append("g")
        .attr("class", "x axis")
        .attr("transform", function(){
            return "translate(" + xStart() + " " + yStart() + " )";
        })
        .call(xAxis);

    d3.selectAll("g.x g.tick")
        .append("line")
          .classed("grid-line", true)
          .attr("x1", 0)
          .attr("y1", 0)
          .attr("x2", 0)
          .attr("y2", - quadrantHeight()) ;
  }
  function renderYAxis(){
    var yAxis = d3.svg.axis()
          .scale(_y.range([quadrantHeight(), 0]))
          .orient("left");

    _axesG.append("g")
        .attr("class", "y axis")
        .attr("transform", function(){
            return "translate(" + xStart() + " " + yEnd() + " )";
        })
        .call(yAxis);

    d3.selectAll("g.y g.tick")
        .append("line")
          .classed("grid-line", true)
          .attr("x1", 0)
          .attr("y1", 0)
          .attr("x2", quadrantWidth())
          .attr("y2", 0) ;
  }
  //render the data
  function renderBody(svg){
    if(!_bodyG){
      _bodyG = svg.append("g")
          .attr("class", "body")
          .attr("transform", "translate(" + xStart() + "," + yEnd() + ")");
    }

    renderFittedLine();  //render first to put on bottom
    renderDots();
  }
  //fitted line
  function renderFittedLine(){
    var dataHatArr = [];  //array to hold the predicted datapoints

    //Fitted Line Formula for Salary Budget
    //recover the plot domain and range in native units (reais)
    var maxBudget = d3.max(_x.domain());
    var minBudget = d3.min(_x.domain());
    var maxSalary = d3.max(_y.domain());
    var minSalary = d3.min(_y.domain());
    dataHatArr.push(d3.range(maxBudget).map(function (i) {
        //this formula comes from regressing salary on city budget for all observations
        var salaryHat = 10.644 + 2.276703 * Math.log(i);
        return {x: i, yhat: salaryHat};
    }));
    dataHat = dataHatArr[0];   //FIXME: shouldnt be necessary
    dataHat.shift();     //dont include log of zero

    //scaling (based on all munis including SP)
    //x goes from values to pixels. Max budget, not SP city budget
    var xLine = d3.scale.linear().domain([minBudget, maxBudget]).range([0, quadrantWidth()]);
    //y from values to pixels and flip
    var yLine = d3.scale.linear().domain([0, maxSalary]).range([quadrantHeight(),0]);

    //plot the fitted line
    _line = d3.svg.line()
        .x(function(d) {return xLine(d.x); })
        .y(function(d) {return yLine(d.yhat); });

    if(!_fittedPath){
      _fittedPath = _bodyG.append("path")
          .attr("d", _line(dataHat))
          .attr("id", "fittedLineSalBudget")
          .attr("class", "fittedLine")
          .attr("transform", "translate(" + 0 + "," + 0 + ")");
    }
  }
  //scatterplot
  function renderDots(){
    _bodyG.selectAll("circle")
        .data(_observations)
        .enter().append("circle")
        .attr("cx", function(d){ return _x(d.budget1M2012); })
        .attr("cy", function(d){ return _y(d.salaryMayor1k2014); })
        .attr("r", function(d){
            if(d.pop1k2012 > 11000){
              //In the case of SP
              return Math.sqrt(d.pop1k2012) / 150; 
            }
            return Math.sqrt(d.pop1k2012); 
        })
        .attr("id", function(d){ return d.muniName; })  //css classes 4 bubbles
        .attr("class", function(d) { 
          classStr = "muniBubble "  //base class name for each circle
          classStr = classStr + d.metroRegion.replace(/\s/g, "_") ; 
          //microregion class
          classStr = classStr + " " + d.microName.replace(/\s/g, "_") ;
          //mayor party class
          classStr = classStr + " " + d.partyOfMayor2012.replace(/\s/g, "_") ;
          //data availability class
          var missing = "";
          if(d.flagSalaryMissing === 1 | d.flagBudgetMissing === 1){
            missing = "dataMissing";
          } else {
            missing = "dataAvailable";
          }
          classStr = classStr + " " + missing;
          return classStr;
        })
        .style("fill", function(d){
            if(d.salaryMayor1k2014 < 0.01 | d.budget1M2012 < 0.01){
              return bubbleColors.background;
            }
            return bubbleColors.main;
        })
        .on("mouseover", function(d){
          d3.select(this)
              .transition().duration(400).ease("quad")
              .style("fill", bubbleColors.flash)
              .style("fill-opacity", 1)
              .style("stroke", bubbleStrokeColor.highlight);
          circleR = Math.sqrt(d.pop1k2012);
          d3.select("#tooltip")
            .transition().duration(400).ease("quad")
            .text(d.muniName)
            .style("opacity", 0.8)
            .style("left", _x(d.budget1M2012) + _margins.left + "px")
            .style("top", _y(d.salaryMayor1k2014) + _margins.top + "px");
        })
        .on("mouseout", function(d){
          d3.select(this)
              .transition().duration(400).ease("quad")
              .style("fill-opacity", 0.8)
              .style("stroke", bubbleStrokeColor.main)
              .style("fill", function(d){
                  if(d.salaryMayor1k2014 < 0.01 | d.budget1M2012 < 0.01){
                    return bubbleColors.background;
                  }
                  return bubbleColors.main;
              })
          d3.select("#tooltip")
            .transition().duration(200).ease("quad")
            .style("opacity", 0);
        })
    
  }
  //Plot Text
  function renderText(svg){
    //determine variable values
    var budgetVar = _variableInfo.filter(function( obj ) {
      return obj.variable === "budget1M2012";
    });
    var salaryVar = _variableInfo.filter(function( obj ) {
      return obj.variable === "salaryMayor1k2014";
    });

    //set variables in chosen language
    if(lang === "EN"){
      xLabel = budgetVar[0].varLabelEN;
      xUnits = budgetVar[0].unitsEN;
      yLabel = salaryVar[0].varLabelEN;
      yUnits = salaryVar[0].unitsEN;
      titleText = "City Budgets and Monthly Mayor Salary*";
      subTitleText = "Brazilian Municipalities in Sao Paulo Metro Region, 2014";
      noteText = "*Size of Bubble based on Population";
    }
    if(lang === "PT"){
      xLabel = budgetVar[0].varLabelPT;
      xUnits = budgetVar[0].unitsPT;
      yLabel = salaryVar[0].varLabelPT;
      yUnits = salaryVar[0].unitsPT;
      //FIXME: These encodings arent working
      titleText = "Orçamento Municipais e Subsídio Mensal do Prefeito*";
      subTitleText = "Municípios na Região Metropolitana de São Paulo, 2014";
      noteText = "*Tamanho da Bolha é baseado em População";
    }
    //place the text on the page
    if(_textG){
      _textG.remove();
    }
    //create text element
     _textG = svg.append("g")
                  .attr("class", "text");
    //x-variable
    _textG.append("text")
      .attr("class", "x label")
      .attr("text-anchor", "middle")
      .attr("x", 0).attr("y", 0)
      .attr("transform", function(){ 
          var xPos = _margins.left + quadrantWidth() / 2 ;
          var yPos = yStart() + 40;  
          return "translate(" + xPos + ", " + yPos + ")"; 
        })
      .text(xLabel + " (" + xUnits + ")");
    //y-variable
    _textG.append("text")
      .attr("class", "y label")
      .attr("text-anchor", "middle")
      .attr("x", 0).attr("y", 0)
      .attr("dy", ".75em")
      .attr("transform", function(){ 
          return "translate(15, " + (yEnd() + quadrantHeight() / 2) + ") rotate(-90)"; 
        })
      .text(yLabel + " (" + yUnits + ")");
    //Title Text
    _textG.append("text")
      .attr("class", "title")
      .attr("text-anchor", "middle")
      .attr("x", 0).attr("y", 0)
      .attr("transform", function(){ 
          var xPos = _margins.left + quadrantWidth() / 2 ;
          var yPos = yEnd() - 40;  
          return "translate(" + xPos + ", " + yPos + ")"; 
        })
      .text(titleText + " ");
    //SubTitle Text
    _textG.append("text")
      .attr("class", "subtitle")
      .attr("text-anchor", "middle")
      .attr("x", 0).attr("y", 0)
      .attr("transform", function(){ 
          var xPos = _margins.left + quadrantWidth() / 2 ;
          var yPos = yEnd() - 20;  
          return "translate(" + xPos + ", " + yPos + ")"; 
        })
      .text(subTitleText);
    //Note Text
    _textG.append("text")
      .attr("class", "note")
      .attr("text-anchor", "middle")
      .attr("x", 0).attr("y", 0)
      .style("font-size", "0.7em")
      .attr("transform", function(){ 
          var xPos = xEnd() - (1.5 * _margins.right) ;
          var yPos = yStart() + _margins.bottom - 10;  
          return "translate(" + xPos + ", " + yPos + ")"; 
        })
      .text(noteText);
  }
  //tooltips
  function renderToolTip(){
    d3.select("body").append("div")
      .attr("id", "tooltip")
      .text("hi im a div")
      .style("opacity", 0);
    
  }

  //positioning functions
  function xStart() {
      return _margins.left;
  }

  function yStart() {
      return _height - _margins.bottom;
  }

  function xEnd() {
      return _width - _margins.right;
  }

  function yEnd() {
      return _margins.top;
  }

  function quadrantWidth() {
      return _width - _margins.left - _margins.right;
  }

  function quadrantHeight() {
      return _height - _margins.top - _margins.bottom;
  }
  function heightOffset() {
      return (quadrantHeight() + _margins.top);
  }
  //accessor functions for objectfn properties
  _chart.observations = function(obs) {
      if (!arguments.length) return _observations;
      _observations = obs;
      return _chart;
  };
  _chart.variableInfo = function(vars) {
      if (!arguments.length) return _variableInfo;
      _variableInfo = vars;
      return _chart;
  };
  _chart.lang = function(l) {
      if (!arguments.length) return lang;
      if (l === "EN"){ lang = l; }
      if (l === "PT"){ lang = l; }
      console.log("Language not Recognized (EN or PT)");
      return _chart;
  };
  _chart.width = function (w) {
      if (!arguments.length) return _width;
      _width = w;
      return _chart;
  };

  _chart.height = function (h) { // <-1C
      if (!arguments.length) return _height;
      _height = h;
      return _chart;
  };

  _chart.margins = function (m) {
      if (!arguments.length) return _margins;
      _margins = m;
      return _chart;
  };

  _chart.colors = function (c) {
      if (!arguments.length) return _colors;
      _colors = c;
      return _chart;
  };

  _chart.x = function (x) {
      if (!arguments.length) return _x;
      _x = x;
      return _chart;
  };

  _chart.y = function (y) {
      if (!arguments.length) return _y;
      _y = y;
      return _chart;
  };
  return _chart;
}

</script>


<!--TODO
-(1) Fix Coloring  (2) Address encoding 

-Calculate salary gap (as a pct) with the predicted level
-default to labeling the outliers and making them different colors

-Style text
-test across browsers (firefox not showing bubbles for some reason)

-Put into my website format
-->
